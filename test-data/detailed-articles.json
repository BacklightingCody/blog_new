{
  "users": [
    {
      "id": 1,
      "username": "techwriter",
      "firstName": "张",
      "lastName": "三",
      "imageUrl": "https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=150&h=150&fit=crop&crop=face"
    },
    {
      "id": 2,
      "username": "codemaster",
      "firstName": "李",
      "lastName": "四",
      "imageUrl": "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=150&h=150&fit=crop&crop=face"
    }
  ],
  "tags": [
    { "id": 1, "name": "React", "slug": "react", "color": "#61DAFB" },
    { "id": 2, "name": "TypeScript", "slug": "typescript", "color": "#3178C6" },
    { "id": 3, "name": "Next.js", "slug": "nextjs", "color": "#000000" },
    { "id": 4, "name": "Node.js", "slug": "nodejs", "color": "#339933" },
    { "id": 5, "name": "数据库", "slug": "database", "color": "#336791" },
    { "id": 6, "name": "前端开发", "slug": "frontend", "color": "#FF6B6B" },
    { "id": 7, "name": "后端开发", "slug": "backend", "color": "#4ECDC4" },
    { "id": 8, "name": "全栈开发", "slug": "fullstack", "color": "#45B7D1" },
    { "id": 9, "name": "性能优化", "slug": "performance", "color": "#96CEB4" },
    { "id": 10, "name": "最佳实践", "slug": "best-practices", "color": "#FFEAA7" }
  ],
  "articles": [
    {
      "id": 1,
      "slug": "react-hooks-complete-guide",
      "title": "React Hooks 完全指南：从入门到精通",
      "summary": "深入探讨React Hooks的核心概念、使用场景和最佳实践，包含大量实战示例和性能优化技巧。",
      "content": "# React Hooks 完全指南：从入门到精通\n\n## 引言\n\nReact Hooks 是 React 16.8 引入的革命性特性，它让我们能够在函数组件中使用状态和其他 React 特性。本文将深入探讨 Hooks 的核心概念和实际应用。\n\n## 什么是 Hooks？\n\nHooks 是一些可以让你在函数组件里\"钩入\" React state 及生命周期等特性的函数。\n\n### 基础 Hooks\n\n#### 1. useState\n\n```javascript\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>你点击了 {count} 次</p>\n      <button onClick={() => setCount(count + 1)}>\n        点击我\n      </button>\n    </div>\n  );\n}\n```\n\n#### 2. useEffect\n\n```javascript\nimport React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // 相当于 componentDidMount 和 componentDidUpdate:\n  useEffect(() => {\n    document.title = `你点击了 ${count} 次`;\n  });\n\n  return (\n    <div>\n      <p>你点击了 {count} 次</p>\n      <button onClick={() => setCount(count + 1)}>\n        点击我\n      </button>\n    </div>\n  );\n}\n```\n\n## 高级 Hooks\n\n### useContext\n\n```javascript\nconst ThemeContext = React.createContext();\n\nfunction App() {\n  return (\n    <ThemeContext.Provider value=\"dark\">\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\nfunction Toolbar() {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n  return (\n    <button style={{ background: theme === 'dark' ? 'black' : 'white' }}>\n      我是一个 {theme} 主题的按钮\n    </button>\n  );\n}\n```\n\n### useReducer\n\n```javascript\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n    </>\n  );\n}\n```\n\n## 自定义 Hooks\n\n```javascript\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch(url);\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n}\n\n// 使用自定义 Hook\nfunction UserProfile({ userId }) {\n  const { data: user, loading, error } = useFetch(`/api/users/${userId}`);\n\n  if (loading) return <div>加载中...</div>;\n  if (error) return <div>错误: {error.message}</div>;\n  if (!user) return <div>用户不存在</div>;\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}\n```\n\n## 性能优化\n\n### useMemo\n\n```javascript\nfunction ExpensiveComponent({ items }) {\n  const expensiveValue = useMemo(() => {\n    return items.reduce((sum, item) => sum + item.value, 0);\n  }, [items]);\n\n  return <div>总计: {expensiveValue}</div>;\n}\n```\n\n### useCallback\n\n```javascript\nfunction Parent({ items }) {\n  const [count, setCount] = useState(0);\n\n  const handleClick = useCallback(() => {\n    console.log('点击了');\n  }, []);\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>计数: {count}</button>\n      <Child onClick={handleClick} />\n    </div>\n  );\n}\n\nconst Child = React.memo(({ onClick }) => {\n  console.log('Child 重新渲染');\n  return <button onClick={onClick}>子组件按钮</button>;\n});\n```\n\n## 最佳实践\n\n### 1. 遵循 Hooks 规则\n- 只在最顶层使用 Hook\n- 只在 React 函数中调用 Hook\n\n### 2. 使用 ESLint 插件\n```bash\nnpm install eslint-plugin-react-hooks --save-dev\n```\n\n### 3. 合理拆分 useEffect\n```javascript\n// ❌ 不好的做法\nuseEffect(() => {\n  // 处理用户数据\n  fetchUser();\n  // 处理订阅\n  const subscription = subscribeToSomething();\n  return () => subscription.unsubscribe();\n}, [userId, someOtherDep]);\n\n// ✅ 好的做法\nuseEffect(() => {\n  fetchUser();\n}, [userId]);\n\nuseEffect(() => {\n  const subscription = subscribeToSomething();\n  return () => subscription.unsubscribe();\n}, [someOtherDep]);\n```\n\n## 总结\n\nReact Hooks 为函数组件带来了强大的能力，让我们能够：\n\n1. **复用状态逻辑** - 通过自定义 Hooks\n2. **简化组件** - 减少类组件的复杂性\n3. **更好的性能** - 通过 useMemo 和 useCallback\n4. **更清晰的代码** - 相关逻辑可以组织在一起\n\n掌握 Hooks 是现代 React 开发的必备技能，希望这篇指南能帮助你更好地理解和使用 Hooks！",
      "html": null,
      "coverImage": "https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=800&h=400&fit=crop",
      "readTime": 15,
      "category": "前端开发",
      "isPublished": true,
      "isDraft": false,
      "viewCount": 1250,
      "likes": 89,
      "bookmarks": 34,
      "comments": 12,
      "userId": 1,
      "createdAt": "2024-01-15T10:00:00Z",
      "updatedAt": "2024-01-20T14:30:00Z",
      "articleTags": [
        { "tagId": 1 },
        { "tagId": 2 },
        { "tagId": 6 },
        { "tagId": 10 }
      ]
    },
    {
      "id": 2,
      "slug": "nodejs-microservices-architecture",
      "title": "Node.js 微服务架构实战：构建可扩展的后端系统",
      "summary": "详细介绍如何使用Node.js构建微服务架构，包括服务拆分、API网关、服务发现、负载均衡等核心概念。",
      "content": "# Node.js 微服务架构实战：构建可扩展的后端系统\n\n## 什么是微服务架构？\n\n微服务架构是一种将单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，并使用轻量级机制（通常是HTTP资源API）进行通信。\n\n![微服务架构图](https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=600&h=300&fit=crop)\n\n## 微服务 vs 单体架构\n\n### 单体架构的问题\n\n```javascript\n// 传统单体应用结构\napp/\n├── controllers/\n│   ├── userController.js\n│   ├── orderController.js\n│   └── productController.js\n├── models/\n│   ├── User.js\n│   ├── Order.js\n│   └── Product.js\n├── routes/\n└── app.js\n```\n\n**问题：**\n- 部署困难\n- 技术栈锁定\n- 扩展性差\n- 故障影响范围大\n\n### 微服务架构的优势\n\n```\n用户服务 (User Service) - Port 3001\n订单服务 (Order Service) - Port 3002  \n产品服务 (Product Service) - Port 3003\nAPI网关 (API Gateway) - Port 3000\n```\n\n**优势：**\n- 独立部署\n- 技术多样性\n- 故障隔离\n- 团队独立性\n\n## 实战：构建微服务系统\n\n### 1. 用户服务 (User Service)\n\n```javascript\n// user-service/app.js\nconst express = require('express');\nconst mongoose = require('mongoose');\nconst app = express();\n\n// 用户模型\nconst UserSchema = new mongoose.Schema({\n  username: { type: String, required: true, unique: true },\n  email: { type: String, required: true, unique: true },\n  password: { type: String, required: true },\n  profile: {\n    firstName: String,\n    lastName: String,\n    avatar: String\n  },\n  createdAt: { type: Date, default: Date.now }\n});\n\nconst User = mongoose.model('User', UserSchema);\n\n// 路由\napp.get('/users/:id', async (req, res) => {\n  try {\n    const user = await User.findById(req.params.id).select('-password');\n    if (!user) {\n      return res.status(404).json({ error: '用户不存在' });\n    }\n    res.json(user);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\napp.post('/users', async (req, res) => {\n  try {\n    const user = new User(req.body);\n    await user.save();\n    res.status(201).json({ id: user._id, username: user.username });\n  } catch (error) {\n    res.status(400).json({ error: error.message });\n  }\n});\n\napp.listen(3001, () => {\n  console.log('用户服务运行在端口 3001');\n});\n```\n\n### 2. 订单服务 (Order Service)\n\n```javascript\n// order-service/app.js\nconst express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst orders = [];\nlet orderIdCounter = 1;\n\n// 创建订单\napp.post('/orders', async (req, res) => {\n  try {\n    const { userId, productId, quantity } = req.body;\n    \n    // 验证用户存在\n    const userResponse = await axios.get(`http://user-service:3001/users/${userId}`);\n    if (!userResponse.data) {\n      return res.status(400).json({ error: '用户不存在' });\n    }\n    \n    // 验证产品存在\n    const productResponse = await axios.get(`http://product-service:3003/products/${productId}`);\n    if (!productResponse.data) {\n      return res.status(400).json({ error: '产品不存在' });\n    }\n    \n    const order = {\n      id: orderIdCounter++,\n      userId,\n      productId,\n      quantity,\n      status: 'pending',\n      total: productResponse.data.price * quantity,\n      createdAt: new Date()\n    };\n    \n    orders.push(order);\n    res.status(201).json(order);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// 获取用户订单\napp.get('/orders/user/:userId', (req, res) => {\n  const userOrders = orders.filter(order => order.userId === req.params.userId);\n  res.json(userOrders);\n});\n\napp.listen(3002, () => {\n  console.log('订单服务运行在端口 3002');\n});\n```\n\n### 3. API 网关\n\n```javascript\n// api-gateway/app.js\nconst express = require('express');\nconst { createProxyMiddleware } = require('http-proxy-middleware');\nconst rateLimit = require('express-rate-limit');\nconst app = express();\n\n// 限流中间件\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15分钟\n  max: 100 // 限制每个IP 15分钟内最多100个请求\n});\n\napp.use(limiter);\n\n// 认证中间件\nconst authenticate = (req, res, next) => {\n  const token = req.headers.authorization;\n  if (!token) {\n    return res.status(401).json({ error: '需要认证' });\n  }\n  // 验证token逻辑\n  next();\n};\n\n// 路由代理\napp.use('/api/users', createProxyMiddleware({\n  target: 'http://user-service:3001',\n  changeOrigin: true,\n  pathRewrite: {\n    '^/api/users': '/users'\n  }\n}));\n\napp.use('/api/orders', authenticate, createProxyMiddleware({\n  target: 'http://order-service:3002',\n  changeOrigin: true,\n  pathRewrite: {\n    '^/api/orders': '/orders'\n  }\n}));\n\napp.use('/api/products', createProxyMiddleware({\n  target: 'http://product-service:3003',\n  changeOrigin: true,\n  pathRewrite: {\n    '^/api/products': '/products'\n  }\n}));\n\napp.listen(3000, () => {\n  console.log('API网关运行在端口 3000');\n});\n```\n\n## Docker 容器化\n\n### 用户服务 Dockerfile\n\n```dockerfile\n# user-service/Dockerfile\nFROM node:16-alpine\n\nWORKDIR /app\n\nCOPY package*.json ./\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3001\n\nCMD [\"node\", \"app.js\"]\n```\n\n### Docker Compose\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  api-gateway:\n    build: ./api-gateway\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - user-service\n      - order-service\n      - product-service\n    environment:\n      - NODE_ENV=production\n\n  user-service:\n    build: ./user-service\n    ports:\n      - \"3001:3001\"\n    environment:\n      - MONGODB_URI=mongodb://mongo:27017/users\n    depends_on:\n      - mongo\n\n  order-service:\n    build: ./order-service\n    ports:\n      - \"3002:3002\"\n    environment:\n      - REDIS_URL=redis://redis:6379\n    depends_on:\n      - redis\n\n  product-service:\n    build: ./product-service\n    ports:\n      - \"3003:3003\"\n    environment:\n      - POSTGRES_URL=postgres://user:pass@postgres:5432/products\n    depends_on:\n      - postgres\n\n  mongo:\n    image: mongo:5\n    volumes:\n      - mongo_data:/data/db\n\n  redis:\n    image: redis:7-alpine\n    volumes:\n      - redis_data:/data\n\n  postgres:\n    image: postgres:14\n    environment:\n      - POSTGRES_DB=products\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=pass\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  mongo_data:\n  redis_data:\n  postgres_data:\n```\n\n## 服务发现与负载均衡\n\n### 使用 Consul 进行服务发现\n\n```javascript\n// service-registry.js\nconst consul = require('consul')();\n\nclass ServiceRegistry {\n  async register(serviceName, serviceId, port, health) {\n    return consul.agent.service.register({\n      name: serviceName,\n      id: serviceId,\n      port: port,\n      check: {\n        http: `http://localhost:${port}${health}`,\n        interval: '10s'\n      }\n    });\n  }\n\n  async discover(serviceName) {\n    const services = await consul.health.service(serviceName);\n    return services[0].filter(service => service.Checks.every(check => check.Status === 'passing'))\n                     .map(service => ({\n                       host: service.Service.Address,\n                       port: service.Service.Port\n                     }));\n  }\n\n  async deregister(serviceId) {\n    return consul.agent.service.deregister(serviceId);\n  }\n}\n\nmodule.exports = ServiceRegistry;\n```\n\n## 监控与日志\n\n### 集中化日志\n\n```javascript\n// logger.js\nconst winston = require('winston');\nconst { ElasticsearchTransport } = require('winston-elasticsearch');\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n  ),\n  defaultMeta: { service: process.env.SERVICE_NAME },\n  transports: [\n    new winston.transports.File({ filename: 'error.log', level: 'error' }),\n    new winston.transports.File({ filename: 'combined.log' }),\n    new ElasticsearchTransport({\n      level: 'info',\n      clientOpts: { node: 'http://elasticsearch:9200' },\n      index: 'logs'\n    })\n  ]\n});\n\nif (process.env.NODE_ENV !== 'production') {\n  logger.add(new winston.transports.Console({\n    format: winston.format.simple()\n  }));\n}\n\nmodule.exports = logger;\n```\n\n### 健康检查\n\n```javascript\n// health-check.js\napp.get('/health', (req, res) => {\n  const healthCheck = {\n    uptime: process.uptime(),\n    message: 'OK',\n    timestamp: Date.now(),\n    checks: {\n      database: 'OK',\n      redis: 'OK',\n      externalAPI: 'OK'\n    }\n  };\n  \n  try {\n    res.status(200).json(healthCheck);\n  } catch (error) {\n    healthCheck.message = error;\n    res.status(503).json(healthCheck);\n  }\n});\n```\n\n## 最佳实践\n\n### 1. 数据一致性\n\n```javascript\n// 使用Saga模式处理分布式事务\nclass OrderSaga {\n  async createOrder(orderData) {\n    const saga = new Saga();\n    \n    try {\n      // 步骤1: 创建订单\n      const order = await saga.add(\n        () => this.orderService.create(orderData),\n        () => this.orderService.cancel(order.id)\n      );\n      \n      // 步骤2: 扣减库存\n      await saga.add(\n        () => this.inventoryService.reserve(orderData.productId, orderData.quantity),\n        () => this.inventoryService.release(orderData.productId, orderData.quantity)\n      );\n      \n      // 步骤3: 处理支付\n      await saga.add(\n        () => this.paymentService.charge(orderData.amount),\n        () => this.paymentService.refund(orderData.amount)\n      );\n      \n      await saga.commit();\n      return order;\n    } catch (error) {\n      await saga.rollback();\n      throw error;\n    }\n  }\n}\n```\n\n### 2. 缓存策略\n\n```javascript\n// 多级缓存\nclass CacheService {\n  constructor() {\n    this.localCache = new Map();\n    this.redisClient = redis.createClient();\n  }\n  \n  async get(key) {\n    // L1: 本地缓存\n    if (this.localCache.has(key)) {\n      return this.localCache.get(key);\n    }\n    \n    // L2: Redis缓存\n    const redisValue = await this.redisClient.get(key);\n    if (redisValue) {\n      this.localCache.set(key, JSON.parse(redisValue));\n      return JSON.parse(redisValue);\n    }\n    \n    return null;\n  }\n  \n  async set(key, value, ttl = 3600) {\n    this.localCache.set(key, value);\n    await this.redisClient.setex(key, ttl, JSON.stringify(value));\n  }\n}\n```\n\n## 总结\n\n微服务架构为现代应用开发带来了：\n\n1. **可扩展性** - 独立扩展各个服务\n2. **可维护性** - 服务边界清晰，职责单一\n3. **技术多样性** - 不同服务可使用不同技术栈\n4. **故障隔离** - 单个服务故障不影响整体系统\n5. **团队自治** - 不同团队可独立开发和部署\n\n但也要注意：\n- 增加了系统复杂性\n- 网络延迟和故障处理\n- 数据一致性挑战\n- 运维复杂度提升\n\n选择微服务架构需要根据团队规模、业务复杂度和技术能力综合考虑。",
      "html": null,
      "coverImage": "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop",
      "readTime": 25,
      "category": "后端开发",
      "isPublished": true,
      "isDraft": false,
      "viewCount": 892,
      "likes": 67,
      "bookmarks": 45,
      "comments": 8,
      "userId": 2,
      "createdAt": "2024-01-10T09:00:00Z",
      "updatedAt": "2024-01-18T16:45:00Z",
      "articleTags": [
        { "tagId": 4 },
        { "tagId": 7 },
        { "tagId": 8 },
        { "tagId": 9 }
      ]
    }
  ]
}
